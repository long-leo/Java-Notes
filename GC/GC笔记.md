# GC讲义与笔记（了解）

## Jvm内存

### 运行时数据区域

​	Java虚拟机在Java程序运行过程中会把它管理的内存，划分为若干个不同的数据区域。
这些区域各自的用途，以及创建和销毁的时间，有的区域随虚拟机的启动而存在，有些区域依赖用户线程的启动和结束而建立和销毁。(比如说栈)
根据《Java虚拟机规范》内存Java虚拟机所管理的内存将会包括如上图的几个运行时数据区

![image-20201223114504559](C:\Users\10754\AppData\Roaming\Typora\typora-user-images\image-20201223114504559.png)



#### 程序计数器

​		程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。(每个线程都有自己的程序计数器，线程隔离)

![image-20201224112558798](C:\Users\10754\AppData\Roaming\Typora\typora-user-images\image-20201224112558798.png)

#### Java栈

​		它描述的是Java 方法执行的内存模型：每个方法被执行的时候都 会同时创建一个栈帧（Stack Frame ）用于存储局部变量表、操作栈、动态链接、方法出口等信息。线程私有(线程隔离)

#### 本地方法栈

​     	本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务

#### Java堆

​    	此内存区域的唯一目的就是存放对象，一个JVM实例只存在一个堆，堆内存的大小是可以调节的。堆内存是线程共享的。

#### 方法区

   	方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量 、静态变量等数据

---



## 内存管理两种方式（画图）

### 显示

显式的内存管理(C/C++)
内存管理(内存的申请和释放)是程序开发者的职责
常见问题：
内存泄漏：内存空间已经申请，使用完毕后未主动释放
野指针：使用了一个指针，但是该指针指向的内存空间已经被free

### 隐式

隐式的内存管理(Java/C#)

内存的管理是由垃圾回收器自动管理的

优点：增加了程序的可靠性，减小了memory leak

缺点：无法控制GC的时间，耗费系统性能

## GC（Garbage Collection）

在JVM中，GC的功能是由垃圾回收器来完成

研究GC，就必须回答下面3个问题：

- 如何确定“垃圾”（画图）
- 如何回收垃圾
- 什么时候回收垃圾（触发GC）

### 如何确定“垃圾”

#### 引用计数算法（画图）

确定哪些对象已经变成了垃圾，最简单的算法就是引用计数法

- 给对象添加一个计数器
- 每当一个地方引用它时，计数器加1
- 每当引用失效时，计数器减1
- 当计数器的数值为0时，也就是对象无法被引用时，表明对象不可在使用，被标记为“垃圾”

但是，这个算法有一个致命的问题，无法解决循环引用的问题。

```java
// 循环引用问题 
public class CircularRefTest {
    private CircularRefTest instance = null; 
    private byte[] buffer = new byte[1024 * 1024];
    public static void main(String[] args) { 
    CircularRefTest a = new CircularRefTest(); 
    CircularRefTest b = new CircularRefTest();
    a.instance = b; 
    b.instance = a;
    a = null;
    b = null; 
    //System.gc(); 
	} 
} 
```

为了解决这个问题，我们引入了另外一种根搜索算法。 

#### 根搜索算法（画图）

根据一个对象是不是垃圾的核心依据来判断，即一个对象能不能被访问到，能就不是垃圾，否则就是垃圾

- 算法的思想是将一系列的被称为“GC Roots”的对象作为搜索的起始点
- 从这些节点往下进行搜索
- 搜索所走的路径称为引用链
- 当一个对象到所有的root之间没有任何引用链相连的时候，就认为该对象变成了垃圾

GC Roots包含什么对象?

- 虚拟机栈中引用的对象，即作为局部变量的引用变量，所指向的对象

我们可以直接访问局部变量，所以作为局部变量的引用变量，我们可以一定访问到的对象

- 方法区中的静态属性引用的对象，即静态的引用变量所指向的对象

我们可以通过类名.静态引用变量方式，访问到静态引用变量，所以静态引用变量指向的对象，就是我们一定可以访问到的对象

从我们一定可以访问到的对象出发，搜索对象的引用，搜索这些对象的引用变量所指向的对象





### 如何回收垃圾

- 标记清除算法(Mark Sweep)
- 标记复制算法(Copy)
- 标记整理算法(Mark Compact)
- 分代收集算法(Generational Collection 商用)

#### 标记清除算法(Mark Sweep)

#### 标记复制算法(Copy)

#### 标记整理算法(Mark Compact)

#### 分代收集算法(Generational Collection)

- 这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块

- 一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的收集算法

- 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集

- 而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-整理”算法进行回收。

  

#### 相关概念 (对象画个图)

- Shallow size

  就是对象本身占用的内存大小，也就是对象头加成员变量占用内存大小的总和

- Retained size

### 什么时候回收垃圾(GC触发时机)

- 申请head space失败后会触发GC
- 系统进入idle后一段时间会进行回收
- 主动调用GC进行回收

### 内存相关问题（画图）

- 堆溢出（Heap OOM）
- 栈溢出（Stack Overflow）

- 内存泄漏（Memory Leak）

  程序中已动态分配的堆内存由于某种原因没释放或者无法释放，造成系统内存的浪费，导致程序运行速度减慢，或崩溃等严重后果。

  - 内存泄漏与内存溢出有联系吗？

    内存泄漏可能导致内存溢出，但不是必然导致内存溢出

